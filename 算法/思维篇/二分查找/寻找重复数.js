/*
287. 寻找重复数
给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。

示例 1：
输入：nums = [1,3,4,2,2]
输出：2

示例 2：
输入：nums = [3,1,3,4,2]
输出：3

示例 3：
输入：nums = [1,1]
输出：1

示例 4：
输入：nums = [1,1,2]
输出：1
 

提示：
1 <= n <= 105
nums.length == n + 1
1 <= nums[i] <= n
nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次
 
进阶：
如何证明 nums 中至少存在一个重复的数字?
你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？
Floyd 判圈算法
*/

var findDuplicate = function (nums) {
    // 二分查找的前提是有序，而题目要求不能改变原数组,那么只能从索引入手。
    //怎么让索引和值联系起来？整数数组能考虑的一个是数值大小，一个是个数。将原数组的值变为新数组的索引，使之有序。于是想到构建一个数组，cnt[i]表示nums数组中小于等于i的数有多少个。普通的升序数组[1,2,3,4,...]这样的cnt==[1,2,3,4,...],而如果有一个元素重复。例如，nums=[1,2,2,3,4],那么cnt==[1,3,4,5];不仅cnt.length==nums.length-1,而且从重复元素那开始cnt中有两个连续元素相差2,即cnt[1]-cnt[0]==2。
    // 此外，为了让额外空间为常数，那么只要相对应求出需要的每一项cnt即可
    
    let l = 0, r = nums.length
    while (l < r) {
        let d = l + Math.floor((r - l)/2)
        let cnt = 0
        for (let i = 0; i < nums.length; i++) {
            cnt += nums[i] <= d
        }
        cnt <= d ? l = d + 1 : r = d
    }
    return l
}