// 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

// 子数组 是数组中的一个连续部分。

// 示例 1：
// 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
// 输出：6
// 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

// 示例 2：
// 输入：nums = [1]
// 输出：1

// 示例 3：
// 输入：nums = [5,4,-1,7,8]
// 输出：23

// 提示：
// 1 <= nums.length <= 105
// -104 <= nums[i] <= 104

// 来源：力扣（LeetCode）
// 链接：https://leetcode-cn.com/problems/maximum-subarray
// 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

// 解题思路如下，思维至上

/*
1.由于是求最大子数组和，一般想法自然是遍历所有的子数组然后求出每一个子数组的和相比较即可得出答案。
可是找出子数组太过麻烦了，而且找出来还要求和再比较，这种思路和计算机的运行思路一致太过僵硬！
更好的办法是什么？我们关注的重点是“和”而不是子数组，子数组只是限制条件，不是关键！既然是求和那自然是关注和！！！
最大和，那就是不断和最大的一个过程。目前能想到的相关联算法思想有：贪心算法，动态规划。
2.求最大和自然是相加的过程，如果相加不能比之前的和大，那么就跳过，如果和比之前大及替换！即状态转移

*/
