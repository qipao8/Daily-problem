#### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632642b312084c00923b7257846efb39~tplv-k3u1fbpfcp-zoom-1.image)

```
输入： height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出： 6
解释： 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入： height = [4,2,0,3,2,5]
输出： 9
```

 

**提示：**

-   `n == height.length`
-   `1 <= n <= 2 * 104`
-   `0 <= height[i] <= 105`

```
// 单调栈
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (height) {
    let stack = [], res = 0
    for (let i = 0; i < height.length; i++) {
        while (stack.length && height[stack.at(-1)] < height[i]) {
            const d = stack.pop() // 栈顶height[d]代表当前底高
            if (!stack.length) break
            let left = stack.at(-1), w = i - left - 1
            let h = Math.min(height[i], height[left]) - height[d]
            res += w * h
        }
        stack.push(i)
    }
    return res
};

// 双指针
var trap = function(height) {
    let ans = 0;
    let left = 0, right = height.length - 1;
    let leftMax = 0, rightMax = 0;
    while (left < right) {
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);
        if (height[left] < height[right]) {
            ans += leftMax - height[left];
            ++left;
        } else {
            ans += rightMax - height[right];
            --right;
        }
    }
    return ans;
};

```